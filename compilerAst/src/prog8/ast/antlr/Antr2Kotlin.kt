package prog8.ast.antlr

import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.tree.TerminalNode
import prog8.ast.Module
import prog8.ast.base.*
import prog8.ast.expressions.*
import prog8.ast.statements.*
import prog8.parser.Prog8ANTLRParser
import java.nio.file.Path


/***************** Antlr Extension methods to create AST ****************/

private data class NumericLiteral(val number: Number, val datatype: DataType)

internal fun Prog8ANTLRParser.ModuleContext.toAst(name: String, isLibrary: Boolean, source: Path) : Module {
    val nameWithoutSuffix = if(name.endsWith(".p8")) name.substringBeforeLast('.') else name
    val directives = this.directive().map { it.toAst() }
    val blocks = this.block().map { it.toAst(isLibrary) }
    return Module(nameWithoutSuffix, (directives + blocks).toMutableList(), toPosition(), isLibrary, source)
}

private fun ParserRuleContext.toPosition() : Position {
    /*
    val customTokensource = this.start.tokenSource as? CustomLexer
    val filename =
            when {
                customTokensource!=null -> customTokensource.modulePath.toString()
                start.tokenSource.sourceName == IntStream.UNKNOWN_SOURCE_NAME -> "@internal@"
                else -> File(start.inputStream.sourceName).name
            }
    */
    val filename = start.inputStream.sourceName

    // note: be ware of TAB characters in the source text, they count as 1 column...
    return Position(filename, start.line, start.charPositionInLine, stop.charPositionInLine + stop.text.length)
}

private fun Prog8ANTLRParser.Block_statementContext.toAst() : Statement {
    variabledeclaration()?.run { return toAst() }
    subroutinedeclaration()?.run { return toAst() }
    directive()?.run { return toAst() }
    inlineasm()?.run { return toAst() }
    labeldef()?.run { return toAst() }
    throw FatalAstException("weird block node $this")
}

private fun Prog8ANTLRParser.BlockContext.toAst(isInLibrary: Boolean) : Block =
    Block(
        identifier().text,
        integerliteral()?.toAst()?.number?.toInt(),
        block_statement().map { it.toAst() }.toMutableList(),
        isInLibrary, toPosition()
    )

private fun Prog8ANTLRParser.Statement_blockContext.toAst(): MutableList<Statement> =
    statement().map { it.toAst() }.toMutableList()

private fun Prog8ANTLRParser.VariabledeclarationContext.toAst() : Statement {
    vardecl()?.run { return toAst() }

    varinitializer()?.run {
        val kind = when {
            const_keyword != null -> VarDeclType.CONST
            memory != null -> VarDeclType.MEMORY
            else -> VarDeclType.VAR
        }
        val decl = vardecl()
        return VarDecl(
            kind,
            declaredDatatype = decl.datatype()?.toAst() ?: DataType.UNDEFINED,
            zeropage = if (decl.ZEROPAGE() != null) ZeropageWish.PREFER_ZEROPAGE else ZeropageWish.DONTCARE,
            arraysize = decl.arrayindex()?.toAst(),
            name = decl.varname.text,
            value = expression().toAst(),
            isArray = decl.ARRAYSIG() != null || decl.arrayindex() != null,
            autogeneratedDontRemove = false,
            sharedWithAsm = decl.SHARED()!=null,
            toPosition()
        )
    }

    throw FatalAstException("weird variable decl $this")
}

private fun Prog8ANTLRParser.SubroutinedeclarationContext.toAst() : Subroutine {
    subroutine()?.run { return toAst() }
    asmsubroutine()?.run { return toAst() }
    romsubroutine()?.run { return toAst() }
    throw FatalAstException("weird subroutine decl $this")
}

private fun Prog8ANTLRParser.StatementContext.toAst() : Statement {
    assignment()?.run {
        return Assignment(assign_target().toAst(), expression().toAst(), toPosition())
    }

    augassignment()?.run {
        // replace A += X  with  A = A + X
        val target = assign_target().toAst()
        val oper = operator.text.substringBefore('=')
        val expression = BinaryExpression(target.toExpression(), oper, expression().toAst(), expression().toPosition())
        return Assignment(assign_target().toAst(), expression, toPosition())
    }

    postincrdecr()?.run {
        return PostIncrDecr(assign_target().toAst(), operator.text, toPosition())
    }

    variabledeclaration()   ?.run { return toAst() }
    directive()             ?.run { return toAst() }
    labeldef()              ?.run { return toAst() }
    unconditionaljump()     ?.run { return toAst() }
    functioncall_stmt()     ?.run { return toAst() }
    if_stmt()               ?.run { return toAst() }
    returnstmt()            ?.run { return toAst() }
    subroutinedeclaration() ?.run { return toAst() }
    inlineasm()             ?.run { return toAst() }
    branch_stmt()           ?.run { return toAst() }
    forloop()               ?.run { return toAst() }
    untilloop()             ?.run { return toAst() }
    whileloop()             ?.run { return toAst() }
    repeatloop()            ?.run { return toAst() }
    breakstmt()             ?.run { return toAst() }
    whenstmt()              ?.run { return toAst() }

    throw FatalAstException("unprocessed source text (are we missing ast conversion rules for parser elements?): $text")
}

private fun Prog8ANTLRParser.AsmsubroutineContext.toAst(): Subroutine {
    val subdecl = asmsub_decl().toAst()
    return Subroutine(
        subdecl.name,
        subdecl.parameters,
        subdecl.returntypes,
        subdecl.asmParameterRegisters,
        subdecl.asmReturnvaluesRegisters,
        subdecl.asmClobbers,
        asmAddress = null,
        isAsmSubroutine = true,
        inline() != null,
        statement_block().toAst(),
        toPosition()
    )
}

private fun Prog8ANTLRParser.RomsubroutineContext.toAst(): Subroutine {
    val subdecl = asmsub_decl().toAst()
    val address = integerliteral().toAst().number.toInt()
    return Subroutine(subdecl.name, subdecl.parameters, subdecl.returntypes,
            subdecl.asmParameterRegisters, subdecl.asmReturnvaluesRegisters,
            subdecl.asmClobbers, address, true, inline = false, statements = mutableListOf(), position = toPosition()
    )
}

private class AsmsubDecl(val name: String,
                         val parameters: List<SubroutineParameter>,
                         val returntypes: List<DataType>,
                         val asmParameterRegisters: List<RegisterOrStatusflag>,
                         val asmReturnvaluesRegisters: List<RegisterOrStatusflag>,
                         val asmClobbers: Set<CpuRegister>)

private fun Prog8ANTLRParser.Asmsub_declContext.toAst(): AsmsubDecl {
    //val asmParams = this.params.map { it.toAst() }
    return AsmsubDecl(
        name = identifier().text,
        parameters = paramDecls.map { SubroutineParameter(it.varname.text, it.datatype().toAst(), it.toPosition()) },
        returntypes = retTypes.map { it.toAst() },
        asmParameterRegisters = paramRegs.map { it.toAst() },
        asmReturnvaluesRegisters = retRegs.map { it.toAst() },
        asmClobbers = this.clobberRegs.map { CpuRegister.valueOf(it.text) }.toSet()
    )
}

private fun Prog8ANTLRParser.RegisterContext.toAst(): RegisterOrStatusflag =
    when (text) {
        in RegisterOrPair.names -> RegisterOrStatusflag(RegisterOrPair.valueOf(text), null)
        in Statusflag.names -> RegisterOrStatusflag(null, Statusflag.valueOf(text))
        else -> throw FatalAstException("invalid register or status flag in $this")
    }

private fun Prog8ANTLRParser.Functioncall_stmtContext.toAst(): Statement {
    val void = this.VOID() != null
    val location = scoped_identifier().toAst()
    return if(expression_list() == null)
        FunctionCallStatement(location, mutableListOf(), void, toPosition())
    else
        FunctionCallStatement(location, expression_list().toAst().toMutableList(), void, toPosition())
}

private fun Prog8ANTLRParser.FunctioncallContext.toAst(): FunctionCall {
    val location = scoped_identifier().toAst()
    return if(expression_list() == null)
        FunctionCall(location, mutableListOf(), toPosition())
    else
        FunctionCall(location, expression_list().toAst().toMutableList(), toPosition())
}

private fun Prog8ANTLRParser.InlineasmContext.toAst() =
        InlineAssembly(INLINEASMBLOCK().text, toPosition())

private fun Prog8ANTLRParser.ReturnstmtContext.toAst() : Return {
    return Return(expression()?.toAst(), toPosition())
}

private fun Prog8ANTLRParser.UnconditionaljumpContext.toAst(): Jump {
    val address = integerliteral()?.toAst()?.number?.toInt()
    val identifier = scoped_identifier()?.toAst()
    return Jump(address, identifier, null, toPosition())
}

private fun Prog8ANTLRParser.LabeldefContext.toAst(): Statement =
        Label(children[0].text, toPosition())

private fun Prog8ANTLRParser.SubroutineContext.toAst() : Subroutine {
    // non-asm subroutine
    val inline = inline()!=null
    val returntypes = sub_return_part()?.toAst() ?: emptyList()
    return Subroutine(identifier().text,
            sub_params()?.toAst() ?: emptyList(),
            returntypes,
            statement_block()?.toAst() ?: mutableListOf(),
            inline,
            toPosition())
}

private fun Prog8ANTLRParser.Sub_return_partContext.toAst(): List<DataType> {
    val returns = sub_returns() ?: return emptyList()
    return returns.datatype().map { it.toAst() }
}

private fun Prog8ANTLRParser.Sub_paramsContext.toAst(): List<SubroutineParameter> =
        vardecl().map {
            val datatype = it.datatype()?.toAst() ?: DataType.UNDEFINED
            SubroutineParameter(it.varname.text, datatype, it.toPosition())
        }

private fun Prog8ANTLRParser.Assign_targetContext.toAst() : AssignTarget {
    val identifier = scoped_identifier()
    return when {
        identifier!=null -> AssignTarget(identifier.toAst(), null, null, toPosition())
        arrayindexed()!=null -> AssignTarget(null, arrayindexed().toAst(), null, toPosition())
        directmemory()!=null -> AssignTarget(null, null, DirectMemoryWrite(directmemory().expression().toAst(), toPosition()), toPosition())
        else -> AssignTarget(scoped_identifier()?.toAst(), null, null, toPosition())
    }
}

private fun Prog8ANTLRParser.DatatypeContext.toAst() = DataType.valueOf(text.uppercase())

private fun Prog8ANTLRParser.ArrayindexContext.toAst() : ArrayIndex =
    ArrayIndex(expression().toAst(), toPosition())

private fun Prog8ANTLRParser.DirectiveContext.toAst() : Directive =
    Directive(directivename.text, directivearg().map { it.toAst() }, toPosition())

private fun Prog8ANTLRParser.DirectiveargContext.toAst() : DirectiveArg {
    val str = stringliteral()
    if(str?.ALT_STRING_ENCODING() != null)
        throw AstException("${toPosition()} can't use alternate string encodings for directive arguments")

    return DirectiveArg(stringliteral()?.text, identifier()?.text, integerliteral()?.toAst()?.number?.toInt(), toPosition())
}

private fun Prog8ANTLRParser.IntegerliteralContext.toAst(): NumericLiteral {
    fun makeLiteral(text: String, radix: Int): NumericLiteral {
        val integer: Int
        var datatype = DataType.UBYTE
        when (radix) {
            10 -> {
                integer = try {
                    text.toInt()
                } catch(x: NumberFormatException) {
                    throw AstException("${toPosition()} invalid decimal literal ${x.message}")
                }
                datatype = when(integer) {
                    in 0..255 -> DataType.UBYTE
                    in -128..127 -> DataType.BYTE
                    in 0..65535 -> DataType.UWORD
                    in -32768..32767 -> DataType.WORD
                    else -> DataType.FLOAT
                }
            }
            2 -> {
                if(text.length>8)
                    datatype = DataType.UWORD
                try {
                    integer = text.toInt(2)
                } catch(x: NumberFormatException) {
                    throw AstException("${toPosition()} invalid binary literal ${x.message}")
                }
            }
            16 -> {
                if(text.length>2)
                    datatype = DataType.UWORD
                try {
                    integer = text.toInt(16)
                } catch(x: NumberFormatException) {
                    throw AstException("${toPosition()} invalid hexadecimal literal ${x.message}")
                }
            }
            else -> throw FatalAstException("invalid radix")
        }
        return NumericLiteral(integer, datatype)
    }
    val terminal: TerminalNode = children[0] as TerminalNode
    val integerPart = this.intpart.text
    return when (terminal.symbol.type) {
        Prog8ANTLRParser.DEC_INTEGER -> makeLiteral(integerPart, 10)
        Prog8ANTLRParser.HEX_INTEGER -> makeLiteral(integerPart.substring(1), 16)
        Prog8ANTLRParser.BIN_INTEGER -> makeLiteral(integerPart.substring(1), 2)
        else -> throw FatalAstException(terminal.text)
    }
}

private fun Prog8ANTLRParser.ExpressionContext.toAst() : Expression {

    val litval = literalvalue()
    if(litval!=null) {
        val booleanlit = litval.booleanliteral()?.toAst()
        return if(booleanlit!=null) {
            NumericLiteralValue.fromBoolean(booleanlit, litval.toPosition())
        }
        else {
            val intLit = litval.integerliteral()?.toAst()
            when {
                intLit!=null -> when(intLit.datatype) {
                    DataType.UBYTE -> NumericLiteralValue(DataType.UBYTE, intLit.number.toShort(), litval.toPosition())
                    DataType.BYTE -> NumericLiteralValue(DataType.BYTE, intLit.number.toShort(), litval.toPosition())
                    DataType.UWORD -> NumericLiteralValue(DataType.UWORD, intLit.number.toInt(), litval.toPosition())
                    DataType.WORD -> NumericLiteralValue(DataType.WORD, intLit.number.toInt(), litval.toPosition())
                    DataType.FLOAT -> NumericLiteralValue(DataType.FLOAT, intLit.number.toDouble(), litval.toPosition())
                    else -> throw FatalAstException("invalid datatype for numeric literal")
                }
                litval.floatliteral()!=null -> NumericLiteralValue(DataType.FLOAT, litval.floatliteral().toAst(), litval.toPosition())
                litval.stringliteral()!=null -> litval.stringliteral().toAst()
                litval.charliteral()!=null -> litval.charliteral().toAst()
                litval.arrayliteral()!=null -> {
                    val array = litval.arrayliteral().toAst()
                    // the actual type of the arraysize can not yet be determined here (missing namespace & heap)
                    // the ConstantFold takes care of that and converts the type if needed.
                    ArrayLiteralValue(InferredTypes.InferredType.unknown(), array, position = litval.toPosition())
                }
                else -> throw FatalAstException("invalid parsed literal")
            }
        }
    }

    if(scoped_identifier()!=null)
        return scoped_identifier().toAst()

    if(bop!=null)
        return BinaryExpression(left.toAst(), bop.text, right.toAst(), toPosition())

    if(prefix!=null)
        return PrefixExpression(prefix.text, expression(0).toAst(), toPosition())

    val funcall = functioncall()?.toAst()
    if(funcall!=null) return funcall

    if (rangefrom!=null && rangeto!=null) {
        val defaultstep = if(rto.text == "to") 1 else -1
        val step = rangestep?.toAst() ?: NumericLiteralValue(DataType.UBYTE, defaultstep, toPosition())
        return RangeExpr(rangefrom.toAst(), rangeto.toAst(), step, toPosition())
    }

    if(childCount==3 && children[0].text=="(" && children[2].text==")")
        return expression(0).toAst()        // expression within ( )

    if(arrayindexed()!=null)
        return arrayindexed().toAst()

    if(typecast()!=null)
        return TypecastExpression(expression(0).toAst(), typecast().datatype().toAst(), false, toPosition())

    if(directmemory()!=null)
        return DirectMemoryRead(directmemory().expression().toAst(), toPosition())

    if(addressof()!=null)
        return AddressOf(addressof().scoped_identifier().toAst(), toPosition())

    throw FatalAstException(text)
}

private fun Prog8ANTLRParser.CharliteralContext.toAst(): CharLiteral =
    CharLiteral(unescape(this.SINGLECHAR().text, toPosition())[0], this.ALT_STRING_ENCODING() != null, toPosition())

private fun Prog8ANTLRParser.StringliteralContext.toAst(): StringLiteralValue =
    StringLiteralValue(unescape(this.STRING().text, toPosition()), ALT_STRING_ENCODING()!=null, toPosition())

private fun Prog8ANTLRParser.ArrayindexedContext.toAst(): ArrayIndexedExpression {
    return ArrayIndexedExpression(scoped_identifier().toAst(),
            arrayindex().toAst(),
            toPosition())
}

private fun Prog8ANTLRParser.Expression_listContext.toAst() = expression().map{ it.toAst() }

private fun Prog8ANTLRParser.IdentifierContext.toAst() : IdentifierReference =
        IdentifierReference(listOf(text), toPosition())

private fun Prog8ANTLRParser.Scoped_identifierContext.toAst() : IdentifierReference =
        IdentifierReference(NAME().map { it.text }, toPosition())

private fun Prog8ANTLRParser.FloatliteralContext.toAst() = text.toDouble()

private fun Prog8ANTLRParser.BooleanliteralContext.toAst() = when(text) {
    "true" -> true
    "false" -> false
    else -> throw FatalAstException(text)
}

private fun Prog8ANTLRParser.ArrayliteralContext.toAst() : Array<Expression> =
        expression().map { it.toAst() }.toTypedArray()

private fun Prog8ANTLRParser.If_stmtContext.toAst(): IfStatement {
    val condition = expression().toAst()
    val trueStatements = statement_block()?.toAst() ?: mutableListOf(statement().toAst())
    val elseStatements = else_part()?.toAst() ?: mutableListOf()
    val trueScope = AnonymousScope(trueStatements, statement_block()?.toPosition()
            ?: statement().toPosition())
    val elseScope = AnonymousScope(elseStatements, else_part()?.toPosition() ?: toPosition())
    return IfStatement(condition, trueScope, elseScope, toPosition())
}

private fun Prog8ANTLRParser.Else_partContext.toAst(): MutableList<Statement> {
    return statement_block()?.toAst() ?: mutableListOf(statement().toAst())
}

private fun Prog8ANTLRParser.Branch_stmtContext.toAst(): BranchStatement {
    val branchcondition = branchcondition().toAst()
    val trueStatements = statement_block()?.toAst() ?: mutableListOf(statement().toAst())
    val elseStatements = else_part()?.toAst() ?: mutableListOf()
    val trueScope = AnonymousScope(trueStatements, statement_block()?.toPosition()
            ?: statement().toPosition())
    val elseScope = AnonymousScope(elseStatements, else_part()?.toPosition() ?: toPosition())
    return BranchStatement(branchcondition, trueScope, elseScope, toPosition())
}

private fun Prog8ANTLRParser.BranchconditionContext.toAst() = BranchCondition.valueOf(
    text.substringAfter('_').uppercase()
)

private fun Prog8ANTLRParser.ForloopContext.toAst(): ForLoop {
    val loopvar = identifier().toAst()
    val iterable = expression()!!.toAst()
    val scope =
            if(statement()!=null)
                AnonymousScope(mutableListOf(statement().toAst()), statement().toPosition())
            else
                AnonymousScope(statement_block().toAst(), statement_block().toPosition())
    return ForLoop(loopvar, iterable, scope, toPosition())
}

private fun Prog8ANTLRParser.BreakstmtContext.toAst() = Break(toPosition())

private fun Prog8ANTLRParser.WhileloopContext.toAst(): WhileLoop {
    val condition = expression().toAst()
    val statements = statement_block()?.toAst() ?: mutableListOf(statement().toAst())
    val scope = AnonymousScope(statements, statement_block()?.toPosition()
            ?: statement().toPosition())
    return WhileLoop(condition, scope, toPosition())
}

private fun Prog8ANTLRParser.RepeatloopContext.toAst(): RepeatLoop {
    val iterations = expression()?.toAst()
    val statements = statement_block()?.toAst() ?: mutableListOf(statement().toAst())
    val scope = AnonymousScope(statements, statement_block()?.toPosition()
            ?: statement().toPosition())
    return RepeatLoop(iterations, scope, toPosition())
}

private fun Prog8ANTLRParser.UntilloopContext.toAst(): UntilLoop {
    val untilCondition = expression().toAst()
    val statements = statement_block()?.toAst() ?: mutableListOf(statement().toAst())
    val scope = AnonymousScope(statements, statement_block()?.toPosition()
            ?: statement().toPosition())
    return UntilLoop(scope, untilCondition, toPosition())
}

private fun Prog8ANTLRParser.WhenstmtContext.toAst(): WhenStatement {
    val condition = expression().toAst()
    val choices = this.when_choice()?.map { it.toAst() }?.toMutableList() ?: mutableListOf()
    return WhenStatement(condition, choices, toPosition())
}

private fun Prog8ANTLRParser.When_choiceContext.toAst(): WhenChoice {
    val values = expression_list()?.toAst()
    val stmt = statement()?.toAst()
    val stmtBlock = statement_block()?.toAst()?.toMutableList() ?: mutableListOf()
    if(stmt!=null)
        stmtBlock.add(stmt)
    val scope = AnonymousScope(stmtBlock, toPosition())
    return WhenChoice(values?.toMutableList(), scope, toPosition())
}

private fun Prog8ANTLRParser.VardeclContext.toAst(): VarDecl {
    return VarDecl(
            VarDeclType.VAR,
            datatype()?.toAst() ?: DataType.UNDEFINED,
            if(ZEROPAGE() != null) ZeropageWish.PREFER_ZEROPAGE else ZeropageWish.DONTCARE,
            arrayindex()?.toAst(),
            varname.text,
            null,
            ARRAYSIG() != null || arrayindex() != null,
            false,
            SHARED()!=null,
            toPosition()
    )
}
